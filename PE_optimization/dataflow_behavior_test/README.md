# Dataflow behavior test

This folder tests the "dataflow" behavior for **double buffering** under *complex control flow*. By complex, we mean there are multiple input and output streams as shown below, rather than the canonical form described in the Xilinx dataflow documents. Note that the producer function has an output that is not used by the consumer; the consumer function takes 2 input stream that is not generated by the producer; but the producer and consumer are indeed dependent on the buffer part.

```
    for (int count = 0; count < LOOP_COUNT; count++) {
#pragma HLS dataflow

        float buffer[BUFFER_LEN];
#pragma HLS resource variable=buffer core=RAM_1P_BRAM

        dataflow_read_input(
            s_in_A, 
            buffer, 
            s_out_A);

        dataflow_write_output(
            s_in_B,
            s_in_C,
            buffer, 
            s_out_B);
    }   
```

We use 1000000 as the dataflow loop count and 128 as the per-function loop count, and the expected hardware execution time should be ~1s. Sometimes HLS incorrectly thinks it can achieve ~1s, yet the real performance is ~2s: the dataflow is not successfully implemented.

**Key Takeaways**

* For non-canonical, HLS can fail to infer dataflow
  * and this is hard to debug, since HLS report shows the double buffering is successful, while on hardware, the performance is the same as without double buffering
* Success and fail versions:
  * these should also be the case no matter using double buffer or streams, as shown in some of other experiments
```
// Success 1: simple and canonical form, single input and single output
    dataflow_read_input(s_in, buffer); // Produce function 
    dataflow_write_output(buffer, s_out); // Consume functions

// Success 2: the producer function has an output that is not used by the consumer
    dataflow_read_input(
        s_in, 
        buffer, 
        s_out_A);

    dataflow_write_output(
        buffer, 
        s_out_B);

// Fail: the consume function takes an input stream that is not produced by the producer
    dataflow_read_input(
        s_in_A, 
        buffer);

    dataflow_write_output(
        s_in_B,
        s_in_C,
        buffer, 
        s_out);
```
* A walk around solution: forwarding inputs
  * A walk around solution is to let the producer takes all inputs, and forward some input streams to the consumer, thus the consumer will only take producer's output as input.
  * Implement the forward stream by a short FIFO (depth=2) will cause deadlock, because in the first iteration, the consumer function won't start load what's in the FIFO until the producer is finished.
  * using a longer FIFO (depth=1024) will be successful. 
    * However, this increases hardware resource usage (significantly?)

```
// Successful walk-around
    float buffer[BUFFER_LEN];
#pragma HLS resource variable=buffer core=RAM_1P_BRAM

    hls::stream<float> s_in_B_forward;
#pragma HLS stream variable=s_in_B_forward depth=1024
    hls::stream<float> s_in_C_forward;
#pragma HLS stream variable=s_in_C_forward depth=1024

    dataflow_read_input(
        s_in_A, 
        s_in_B,
        s_in_C,
        buffer, 
        s_out_A,
        s_in_B_forward,
        s_in_C_forward);

    dataflow_write_output(
        s_in_B_forward,
        s_in_C_forward,
        buffer, 
        s_out_B);
```

## Test 1 -> Canonical form, baseline

Single input stream; single output stream; one double buffer

Performance test success

```
void double_buffer_loop(
    hls::stream<float> &s_in, 
    hls::stream<float> &s_out) {

    // double buffer
    float buffer[BUFFER_LEN];

    // each function ~128 CC
    // 128 * 1000000 * (1/140/1e6) = 0.914 sec
    for (int count = 0; count < LOOP_COUNT; count++) {
#pragma HLS dataflow
        dataflow_read_input(s_in, buffer);
        dataflow_write_output(buffer, s_out);
    }    
}
```


* HLS Estimation (top-level):

The overall latency estimated by HLS is overestimated, since it doesn't consider overlaps.

```
================================================================
== Performance Estimates
================================================================
+ Timing:
    * Summary:
    +--------+---------+----------+------------+
    |  Clock |  Target | Estimated| Uncertainty|
    +--------+---------+----------+------------+
    |ap_clk  | 7.14 ns | 5.214 ns |   1.93 ns  |
    +--------+---------+----------+------------+

+ Latency:
    * Summary:
    +-----------+-----------+-----------+-----------+-----------+-----------+----------+
    |    Latency (cycles)   |   Latency (absolute)  |        Interval       | Pipeline |
    |    min    |    max    |    min    |    max    |    min    |    max    |   Type   |
    +-----------+-----------+-----------+-----------+-----------+-----------+----------+
    |  266999887|  266999887| 1.907 sec | 1.907 sec |  135000133|  135000133| dataflow |
    +-----------+-----------+-----------+-----------+-----------+-----------+----------+

    + Detail:
        * Instance:
        +-----------------------+--------------------+-----------+-----------+-----------+-----------+-----------+-----------+---------+
        |                       |                    |    Latency (cycles)   |   Latency (absolute)  |        Interval       | Pipeline|
        |        Instance       |       Module       |    min    |    max    |    min    |    max    |    min    |    max    |   Type  |
        +-----------------------+--------------------+-----------+-----------+-----------+-----------+-----------+-----------+---------+
        |double_buffer_loop_U0  |double_buffer_loop  |  135000132|  135000132| 0.964 sec | 0.964 sec |  135000132|  135000132|   none  |
        |read_input10_U0        |read_input10        |  128000139|  128000139| 0.914 sec | 0.914 sec |  128000139|  128000139|   none  |
        |write_output_U0        |write_output        |  128000137|  128000137| 0.914 sec | 0.914 sec |  128000137|  128000137|   none  |
        +-----------------------+--------------------+-----------+-----------+-----------+-----------+-----------+-----------+---------+


```

* HLS Estimation (dataflow function):

```
+ Latency: 
    * Summary: 
    +-----------+-----------+-----------+-----------+-----------+-----------+---------+
    |    Latency (cycles)   |   Latency (absolute)  |        Interval       | Pipeline|
    |    min    |    max    |    min    |    max    |    min    |    max    |   Type  |
    +-----------+-----------+-----------+-----------+-----------+-----------+---------+
    |  135000132|  135000132| 0.964 sec | 0.964 sec |  135000132|  135000132|   none  |
    +-----------+-----------+-----------+-----------+-----------+-----------+---------+

    + Detail: 
        * Instance: 
        +---------------------+------------------+---------+---------+----------+----------+-----+-----+----------+
        |                     |                  |  Latency (cycles) |  Latency (absolute) |  Interval | Pipeline |
        |       Instance      |      Module      |   min   |   max   |    min   |    max   | min | max |   Type   |
        +---------------------+------------------+---------+---------+----------+----------+-----+-----+----------+
        |dataflow_in_loop_U0  |dataflow_in_loop  |      265|      265| 1.893 us | 1.893 us |  135|  135| dataflow |
        +---------------------+------------------+---------+---------+----------+----------+-----+-----+----------+

        * Loop: 
        +----------+-----------+-----------+----------+-----------+-----------+---------+----------+
        |          |    Latency (cycles)   | Iteration|  Initiation Interval  |   Trip  |          |
        | Loop Name|    min    |    max    |  Latency |  achieved |   target  |  Count  | Pipelined|
        +----------+-----------+-----------+----------+-----------+-----------+---------+----------+
        |- Loop 1  |  135000131|  135000131|       267|          -|          -|  1000000|    no    |
        +----------+-----------+-----------+----------+-----------+-----------+---------+----------+
```

* Real Performance: 972 ms -> same as dataflow function

## Test 2 -> performance fails

Multiple input streams; multiple output streams; one double buffer

Performance test fails

```
void dataflow_read_input(
    hls::stream<float> &s_in_A,
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out_A) {

    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float reg = s_in_A.read();
        buffer[i] = reg;
        s_out_A.write(reg);
    } 
}

void dataflow_write_output(
    hls::stream<float> &s_in_B,
    hls::stream<float> &s_in_C,
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out_B) {

    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float result = s_in_B.read() + s_in_C.read() + buffer[i];
        s_out_B.write(result);
    } 
}

void double_buffer_loop(
    hls::stream<float> &s_in_A, 
    hls::stream<float> &s_in_B, 
    hls::stream<float> &s_in_C, 
    hls::stream<float> &s_out_A,
    hls::stream<float> &s_out_B) { 

    // each function ~128 CC
    // 128 * 1000000 * (1/140/1e6) = 0.914 sec
    for (int count = 0; count < LOOP_COUNT; count++) {
#pragma HLS dataflow

        float buffer[BUFFER_LEN];
#pragma HLS resource variable=buffer core=RAM_1P_BRAM

        dataflow_read_input(
            s_in_A, 
            buffer, 
            s_out_A);

        dataflow_write_output(
            s_in_B,
            s_in_C,
            buffer, 
            s_out_B);
    }    
}
```

* HLS Performance (dataflow function):

```
    * Summary: 
    +-----------+-----------+-----------+-----------+-----------+-----------+---------+
    |    Latency (cycles)   |   Latency (absolute)  |        Interval       | Pipeline|
    |    min    |    max    |    min    |    max    |    min    |    max    |   Type  |
    +-----------+-----------+-----------+-----------+-----------+-----------+---------+
    |  140000132|  140000132| 1.000 sec | 1.000 sec |  140000132|  140000132|   none  |
    +-----------+-----------+-----------+-----------+-----------+-----------+---------
```

* Real Performance: 1936.39 ms

## Test 3 -> Performance fails

The consumer takes another input stream (not the output of the producer).

```
void dataflow_read_input(
    hls::stream<float> &s_in_A,
    float buffer[BUFFER_LEN]) {

    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float reg = s_in_A.read();
        buffer[i] = reg;
    } 
}

void dataflow_write_output(
    hls::stream<float> &s_in_B,
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out) {

    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float result = s_in_B.read() + buffer[i];
        s_out.write(result);
    } 
}

void double_buffer_loop(
    hls::stream<float> &s_in_A, 
    hls::stream<float> &s_in_B, 
    hls::stream<float> &s_out) { 

    // each function ~128 CC
    // 128 * 1000000 * (1/140/1e6) = 0.914 sec
    for (int count = 0; count < LOOP_COUNT; count++) {
#pragma HLS dataflow

        float buffer[BUFFER_LEN];
#pragma HLS resource variable=buffer core=RAM_1P_BRAM

        dataflow_read_input(
            s_in_A, 
            buffer);

        dataflow_write_output(
            s_in_B,
            buffer, 
            s_out);
    }    
}
```

* HLS Performance (dataflow function): ~1s

* Real Performance: 1907 ms

## Test 4 -> Success

The producer outputs another stream that is not used by the consumer.

* HLS Performance (dataflow function):

```
void dataflow_read_input(
    hls::stream<float> &s_in,
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out_A) {
        
    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float reg = s_in.read();
        buffer[i] = reg;
        s_out_A.write(reg);
    } 
}

void dataflow_write_output(
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out_B) {

    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float result = buffer[i];
        s_out_B.write(result);
    } 
}

void double_buffer_loop(
    hls::stream<float> &s_in, 
    hls::stream<float> &s_out_A,
    hls::stream<float> &s_out_B) { 

    // each function ~128 CC
    // 128 * 1000000 * (1/140/1e6) = 0.914 sec
    for (int count = 0; count < LOOP_COUNT; count++) {
#pragma HLS dataflow

        float buffer[BUFFER_LEN];
#pragma HLS resource variable=buffer core=RAM_1P_BRAM

        dataflow_read_input(
            s_in, 
            buffer, 
            s_out_A);

        dataflow_write_output(
            buffer, 
            s_out_B);
    }    
}
```

* Real Performance: 943 ms


## Test 5 -> Walk around, deadlock fail

Now, the behavior is that, the consumer must only takes the producer's output as its input stream. The producer can output other streams that is not used by the consumer anyway.

A walk around solution is to let the producer takes all inputs, and forward some input streams to the consumer, thus the consumer will only take producer's output as input.

Implement the forward stream by a short FIFO (depth=2) will cause deadlock, because in the first iteration, the consumer function won't start load what's in the FIFO until the producer is finished.

```
void dataflow_read_input(
    hls::stream<float> &s_in_A,
    hls::stream<float> &s_in_B,
    hls::stream<float> &s_in_C,
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out_A,
    hls::stream<float> &s_in_B_forward,
    hls::stream<float> &s_in_C_forward) {


// TODO: what if forward content (B,C) and A cannot be presented in the same loop? 
//   need extra control logic then
    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1

        // double buffer
        float reg = s_in_A.read();
        buffer[i] = reg;

        // output of this function
        s_out_A.write(reg);

        // forward input to the next dataflow function
        s_in_B_forward.write(s_in_B.read());
        s_in_C_forward.write(s_in_C.read());
    } 
}

void dataflow_write_output(
    hls::stream<float> &s_in_B_forward,
    hls::stream<float> &s_in_C_forward,
    float buffer[BUFFER_LEN],
    hls::stream<float> &s_out_B) {

    for (int i = 0; i < BUFFER_LEN; i++) {
#pragma HLS pipeline II=1
        float result = s_in_B_forward.read() + s_in_C_forward.read() + buffer[i];
        s_out_B.write(result);
    } 
}

void double_buffer_loop(
    hls::stream<float> &s_in_A, 
    hls::stream<float> &s_in_B, 
    hls::stream<float> &s_in_C, 
    hls::stream<float> &s_out_A,
    hls::stream<float> &s_out_B) { 

    // each function ~128 CC
    // 128 * 1000000 * (1/140/1e6) = 0.914 sec
    for (int count = 0; count < LOOP_COUNT; count++) {
#pragma HLS dataflow

        float buffer[BUFFER_LEN];
#pragma HLS resource variable=buffer core=RAM_1P_BRAM

        hls::stream<float> s_in_B_forward;
#pragma HLS stream variable=s_in_B_forward depth=2
        hls::stream<float> s_in_C_forward;
#pragma HLS stream variable=s_in_C_forward depth=2

        dataflow_read_input(
            s_in_A, 
            s_in_B,
            s_in_C,
            buffer, 
            s_out_A,
            s_in_B_forward,
            s_in_C_forward);

        dataflow_write_output(
            s_in_B_forward,
            s_in_C_forward,
            buffer, 
            s_out_B);
    }    
}
```

* HLS Performance (dataflow function): ~1s

* Real Performance: deadlock

## Test 6 -> Success, but needs more resources

Same as test 5, but using a longer FIFO (depth=1024). However, this increases hardware resource usage (significantly?).

* HLS Performance (dataflow function): ~1s

* Real Performance: 1007 ms
